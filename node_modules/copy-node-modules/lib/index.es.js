import path from 'path';
import fs from 'graceful-fs';
import ncp from 'ncp';
import async from 'async';
import semver from 'semver';
import jsonfile from 'jsonfile';
import mkdirp from 'mkdirp';
import flatten from 'lodash.flatten';
import uniqWith from 'lodash.uniqwith';

var gOpts = {};

function dirExists(directory) {
  try {
    return fs.lstatSync(directory).isDirectory();
  } catch (e) {
    return false;
  }
}

function getPackageJson(pkgDir) {
  var pkgPath = path.resolve(pkgDir, 'package.json');

  try {
    return jsonfile.readFileSync(pkgPath, {
      throws: false
    });
  } catch (e) {
    // skip missing modules
    return null;
  }
}

function hasPackage(pkg, pkgs) {
  var name = pkg.name,
      version = pkg.version;

  for (var i = 0; i < pkgs.length; i += 1) {
    if (pkgs[i].name === name && pkgs[i].version === version) {
      return true;
    }
  }

  return false;
}

function addPkgDeps(baseDir, pkg, pkgs, callback) {
  var pkgDir = path.resolve(baseDir, "node_modules/".concat(pkg.name));
  var pkgContent = getPackageJson(pkgDir);

  if (!pkgContent) {
    return;
  }

  if (hasPackage(pkgContent, pkgs)) {
    return;
  }

  if (baseDir === gOpts.srcDir) {
    var name = pkgContent.name,
        version = pkgContent.version;

    if (!semver.validRange(pkg.version) || semver.satisfies(pkgContent.version, pkg.version)) {
      pkgs.push({
        name: name,
        version: version
      });
    }
  } // recursive search sub modules


  var subPkgBase = path.resolve(pkgDir, 'node_modules');

  if (dirExists(subPkgBase)) {
    var subPkgs = fs.readdirSync(subPkgBase);
    subPkgs.forEach(function (name) {
      return addPkgDeps(pkgDir, {
        name: name,
        version: '*'
      }, pkgs, callback);
    });
  }

  Object.keys(pkgContent.dependencies || {}).forEach(function (name) {
    var version = pkgContent.dependencies[name];

    if (!version.startsWith('file:')) {
      var depPkg = {
        name: name,
        version: version
      };
      addPkgDeps(gOpts.srcDir, depPkg, pkgs, callback);
      addPkgDeps(pkgDir, depPkg, pkgs, callback);
    }
  });
}

function findPkgDeps(pkg, callback) {
  var pkgs = [];
  addPkgDeps(gOpts.srcDir, pkg, pkgs, callback);
  callback(null, pkgs);
}

function copyModules(pkgContent, callback) {
  var name = pkgContent.name;
  var srcDir = path.resolve(gOpts.srcDir, "node_modules/".concat(name));
  var dstDir = path.resolve(gOpts.dstDir, "node_modules/".concat(name));
  var _gOpts = gOpts,
      filter = _gOpts.filter;
  mkdirp.sync(dstDir);
  var opts = {
    clobber: false,
    dereference: true,
    filter: filter
  };
  ncp(srcDir, dstDir, opts, function (err) {
    return callback(err);
  });
}
/**
 * @param {String} srcDir
 * @param {String} dstDir
 * @param {Object} [opts]
 * @param {Boolean} [opts.devDependencies=false]
 * @param {Number} [opts.concurrency]
 * @param {string} [opts.filter]
 * @param {Function} callback
 */


function copyNodeModules(srcDir, dstDir, opts, callback) {
  if (!srcDir) {
    throw new TypeError('Missing source directory argument.');
  }

  if (!dstDir) {
    throw new TypeError('Missing destination diretory argument.');
  }

  if (!callback) {
    gOpts = {
      srcDir: srcDir,
      dstDir: dstDir,
      devDependencies: false
    };
    callback = opts;
  } else {
    gOpts = opts || {};
    gOpts.srcDir = gOpts.srcDir || srcDir;
    gOpts.dstDir = dstDir;
  }

  var pkgPath = path.resolve(srcDir, './package.json');
  var pkgContent = jsonfile.readFileSync(pkgPath, {
    throws: false
  });

  if (!pkgContent) {
    throw new Error('Parsing package.json in source directory fail.');
  } // prepare root package list


  var version;
  var rootPkgList = [];
  Object.keys(pkgContent.dependencies).forEach(function (name) {
    version = pkgContent.dependencies[name];

    if (!version.startsWith('file:')) {
      rootPkgList.push({
        name: name,
        version: version
      });
    }
  });

  if (gOpts.devDependencies) {
    Object.keys(pkgContent.devDependencies).forEach(function (name) {
      version = pkgContent.devDependencies[name];

      if (!version.startsWith('file:')) {
        rootPkgList.push({
          name: name,
          version: version
        });
      }
    });
  }

  async.map(rootPkgList, findPkgDeps, function (err, results) {
    if (err) {
      callback(err);
      return;
    }

    var dstModuleDir = path.resolve(gOpts.dstDir, 'node_modules');
    fs.stat(dstModuleDir, function (err, stat) {
      if (err || !stat.isDirectory()) {
        if (!mkdirp.sync(dstModuleDir)) {
          callback('Can not create destination node_modules directory.');
          return;
        }
      }

      var allPkgList = uniqWith(flatten(results), function (a, b) {
        return a.name === b.name && a.version === b.version;
      });

      if (gOpts.concurrency) {
        var queue = async.queue(copyModules, gOpts.concurrency);

        queue.drain = function () {
          return callback(null, allPkgList);
        };

        queue.push(allPkgList, function (err) {
          if (err) {
            queue.kill();
            callback(err, allPkgList);
          }
        });
      } else {
        async.each(allPkgList, copyModules, function (err) {
          return callback(err, allPkgList);
        });
      }
    });
  });
}

export default copyNodeModules;
