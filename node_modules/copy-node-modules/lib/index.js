"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _gracefulFs = _interopRequireDefault(require("graceful-fs"));

var _ncp = _interopRequireDefault(require("ncp"));

var _async = _interopRequireDefault(require("async"));

var _semver = _interopRequireDefault(require("semver"));

var _jsonfile = _interopRequireDefault(require("jsonfile"));

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _lodash = _interopRequireDefault(require("lodash.flatten"));

var _lodash2 = _interopRequireDefault(require("lodash.uniqwith"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var gOpts = {};

function dirExists(directory) {
  try {
    return _gracefulFs.default.lstatSync(directory).isDirectory();
  } catch (e) {
    return false;
  }
}

function getPackageJson(pkgDir) {
  var pkgPath = _path.default.resolve(pkgDir, 'package.json');

  try {
    return _jsonfile.default.readFileSync(pkgPath, {
      throws: false
    });
  } catch (e) {
    // skip missing modules
    return null;
  }
}

function hasPackage(pkg, pkgs) {
  var name = pkg.name,
      version = pkg.version;

  for (var i = 0; i < pkgs.length; i += 1) {
    if (pkgs[i].name === name && pkgs[i].version === version) {
      return true;
    }
  }

  return false;
}

function addPkgDeps(baseDir, pkg, pkgs, callback) {
  var pkgDir = _path.default.resolve(baseDir, "node_modules/".concat(pkg.name));

  var pkgContent = getPackageJson(pkgDir);

  if (!pkgContent) {
    return;
  }

  if (hasPackage(pkgContent, pkgs)) {
    return;
  }

  if (baseDir === gOpts.srcDir) {
    var name = pkgContent.name,
        version = pkgContent.version;

    if (!_semver.default.validRange(pkg.version) || _semver.default.satisfies(pkgContent.version, pkg.version)) {
      pkgs.push({
        name: name,
        version: version
      });
    }
  } // recursive search sub modules


  var subPkgBase = _path.default.resolve(pkgDir, 'node_modules');

  if (dirExists(subPkgBase)) {
    var subPkgs = _gracefulFs.default.readdirSync(subPkgBase);

    subPkgs.forEach(function (name) {
      return addPkgDeps(pkgDir, {
        name: name,
        version: '*'
      }, pkgs, callback);
    });
  }

  Object.keys(pkgContent.dependencies || {}).forEach(function (name) {
    var version = pkgContent.dependencies[name];

    if (!version.startsWith('file:')) {
      var depPkg = {
        name: name,
        version: version
      };
      addPkgDeps(gOpts.srcDir, depPkg, pkgs, callback);
      addPkgDeps(pkgDir, depPkg, pkgs, callback);
    }
  });
}

function findPkgDeps(pkg, callback) {
  var pkgs = [];
  addPkgDeps(gOpts.srcDir, pkg, pkgs, callback);
  callback(null, pkgs);
}

function copyModules(pkgContent, callback) {
  var name = pkgContent.name;

  var srcDir = _path.default.resolve(gOpts.srcDir, "node_modules/".concat(name));

  var dstDir = _path.default.resolve(gOpts.dstDir, "node_modules/".concat(name));

  var _gOpts = gOpts,
      filter = _gOpts.filter;

  _mkdirp.default.sync(dstDir);

  var opts = {
    clobber: false,
    dereference: true,
    filter: filter
  };
  (0, _ncp.default)(srcDir, dstDir, opts, function (err) {
    return callback(err);
  });
}
/**
 * @param {String} srcDir
 * @param {String} dstDir
 * @param {Object} [opts]
 * @param {Boolean} [opts.devDependencies=false]
 * @param {Number} [opts.concurrency]
 * @param {string} [opts.filter]
 * @param {Function} callback
 */


function copyNodeModules(srcDir, dstDir, opts, callback) {
  if (!srcDir) {
    throw new TypeError('Missing source directory argument.');
  }

  if (!dstDir) {
    throw new TypeError('Missing destination diretory argument.');
  }

  if (!callback) {
    gOpts = {
      srcDir: srcDir,
      dstDir: dstDir,
      devDependencies: false
    };
    callback = opts;
  } else {
    gOpts = opts || {};
    gOpts.srcDir = gOpts.srcDir || srcDir;
    gOpts.dstDir = dstDir;
  }

  var pkgPath = _path.default.resolve(srcDir, './package.json');

  var pkgContent = _jsonfile.default.readFileSync(pkgPath, {
    throws: false
  });

  if (!pkgContent) {
    throw new Error('Parsing package.json in source directory fail.');
  } // prepare root package list


  var version;
  var rootPkgList = [];
  Object.keys(pkgContent.dependencies).forEach(function (name) {
    version = pkgContent.dependencies[name];

    if (!version.startsWith('file:')) {
      rootPkgList.push({
        name: name,
        version: version
      });
    }
  });

  if (gOpts.devDependencies) {
    Object.keys(pkgContent.devDependencies).forEach(function (name) {
      version = pkgContent.devDependencies[name];

      if (!version.startsWith('file:')) {
        rootPkgList.push({
          name: name,
          version: version
        });
      }
    });
  }

  _async.default.map(rootPkgList, findPkgDeps, function (err, results) {
    if (err) {
      callback(err);
      return;
    }

    var dstModuleDir = _path.default.resolve(gOpts.dstDir, 'node_modules');

    _gracefulFs.default.stat(dstModuleDir, function (err, stat) {
      if (err || !stat.isDirectory()) {
        if (!_mkdirp.default.sync(dstModuleDir)) {
          callback('Can not create destination node_modules directory.');
          return;
        }
      }

      var allPkgList = (0, _lodash2.default)((0, _lodash.default)(results), function (a, b) {
        return a.name === b.name && a.version === b.version;
      });

      if (gOpts.concurrency) {
        var queue = _async.default.queue(copyModules, gOpts.concurrency);

        queue.drain = function () {
          return callback(null, allPkgList);
        };

        queue.push(allPkgList, function (err) {
          if (err) {
            queue.kill();
            callback(err, allPkgList);
          }
        });
      } else {
        _async.default.each(allPkgList, copyModules, function (err) {
          return callback(err, allPkgList);
        });
      }
    });
  });
}

var _default = copyNodeModules;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;